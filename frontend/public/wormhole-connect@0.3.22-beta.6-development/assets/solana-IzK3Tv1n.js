const __vite__fileDeps=["assets/index-WaFPCx4Z.js","main.js","main.css","assets/chain-DNXEv05f.js","assets/index-DTi89_IP.js","assets/index-CRraEWoJ.js","assets/create-8iCA8uMR.js","assets/index-DsBgYJHX.js","assets/index-BaiE0GrD.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
var rn=Object.defineProperty;var on=(i,e,t)=>e in i?rn(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var U=(i,e,t)=>(on(i,typeof e!="symbol"?e+"":e,t),t);import{a5 as M,aI as ft,o as C,aJ as gt,aK as D,aL as I,aM as B,aN as J,aO as P,aP as $,aQ as ke,aR as Q,aS as Tt,aT as O,aU as Ce,aV as an,aW as cn,aX as un,aY as ln,aZ as dn,a_ as hn,a$ as fn,b0 as gn,ax as pt,aw as Ye,ay as pn,_ as We,az as mn,aA as yn,aB as bn,aC as $e,aD as wn,aE as kn,b1 as Sn,aH as _n}from"../main.js";import{C as An,P as In}from"./chain-DNXEv05f.js";class Rn extends TypeError{constructor(e,t){let n;const{message:s,...r}=e,{path:o}=e,a=o.length===0?s:"At path: "+o.join(".")+" -- "+s;super(a),Object.assign(this,r),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[e,...t()]}}}function Bn(i){return le(i)&&typeof i[Symbol.iterator]=="function"}function le(i){return typeof i=="object"&&i!=null}function ee(i){return typeof i=="string"?JSON.stringify(i):""+i}function En(i){const{done:e,value:t}=i.next();return e?void 0:t}function Tn(i,e,t,n){if(i===!0)return;i===!1?i={}:typeof i=="string"&&(i={message:i});const{path:s,branch:r}=e,{type:o}=t,{refinement:a,message:c="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+ee(n)+"`"}=i;return{value:n,type:o,refinement:a,key:s[s.length-1],path:s,branch:r,...i,message:c}}function*mt(i,e,t,n){Bn(i)||(i=[i]);for(const s of i){const r=Tn(s,e,t,n);r&&(yield r)}}function*rt(i,e,t={}){const{path:n=[],branch:s=[i],coerce:r=!1,mask:o=!1}=t,a={path:n,branch:s};if(r&&(i=e.coercer(i,a),o&&e.type!=="type"&&le(e.schema)&&le(i)&&!Array.isArray(i)))for(const l in i)e.schema[l]===void 0&&delete i[l];let c=!0;for(const l of e.validator(i,a))c=!1,yield[l,void 0];for(let[l,h,k]of e.entries(i,a)){const R=rt(h,k,{path:l===void 0?n:[...n,l],branch:l===void 0?s:[...s,h],coerce:r,mask:o});for(const b of R)b[0]?(c=!1,yield[b[0],void 0]):r&&(h=b[1],l===void 0?i=h:i instanceof Map?i.set(l,h):i instanceof Set?i.add(h):le(i)&&(i[l]=h))}if(c)for(const l of e.refiner(i,a))c=!1,yield[l,void 0];c&&(yield[void 0,i])}let se=class{constructor(e){const{type:t,schema:n,validator:s,refiner:r,coercer:o=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=o,s?this.validator=(c,l)=>{const h=s(c,l);return mt(h,l,this,c)}:this.validator=()=>[],r?this.refiner=(c,l)=>{const h=r(c,l);return mt(h,l,this,c)}:this.refiner=()=>[]}assert(e){return xn(e,this)}create(e){return p(e,this)}is(e){return xt(e,this)}mask(e){return Cn(e,this)}validate(e,t={}){return ve(e,this,t)}};function xn(i,e){const t=ve(i,e);if(t[0])throw t[0]}function p(i,e){const t=ve(i,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Cn(i,e){const t=ve(i,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function xt(i,e){return!ve(i,e)[0]}function ve(i,e,t={}){const n=rt(i,e,t),s=En(n);return s[0]?[new Rn(s[0],function*(){for(const o of n)o[0]&&(yield o[0])}),void 0]:[void 0,s[1]]}function pe(i,e){return new se({type:i,schema:null,validator:e})}function vn(){return pe("any",()=>!0)}function w(i){return new se({type:"array",schema:i,*entries(e){if(i&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,i]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+ee(e)}})}function ne(){return pe("boolean",i=>typeof i=="boolean")}function ot(i){return pe("instance",e=>e instanceof i||"Expected a `"+i.name+"` instance, but received: "+ee(e))}function N(i){const e=ee(i),t=typeof i;return new se({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?i:null,validator(n){return n===i||"Expected the literal `"+e+"`, but received: "+ee(n)}})}function Pn(){return pe("never",()=>!1)}function y(i){return new se({...i,validator:(e,t)=>e===null||i.validator(e,t),refiner:(e,t)=>e===null||i.refiner(e,t)})}function u(){return pe("number",i=>typeof i=="number"&&!isNaN(i)||"Expected a number, but received: "+ee(i))}function E(i){return new se({...i,validator:(e,t)=>e===void 0||i.validator(e,t),refiner:(e,t)=>e===void 0||i.refiner(e,t)})}function Ct(i,e){return new se({type:"record",schema:null,*entries(t){if(le(t))for(const n in t){const s=t[n];yield[n,n,i],yield[n,s,e]}},validator(t){return le(t)||"Expected an object, but received: "+ee(t)}})}function g(){return pe("string",i=>typeof i=="string"||"Expected a string, but received: "+ee(i))}function it(i){const e=Pn();return new se({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(i.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],i[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+ee(t)}})}function d(i){const e=Object.keys(i);return new se({type:"type",schema:i,*entries(t){if(le(t))for(const n of e)yield[n,t[n],i[n]]},validator(t){return le(t)||"Expected an object, but received: "+ee(t)}})}function V(i){const e=i.map(t=>t.type).join(" | ");return new se({type:"union",schema:null,validator(t,n){const s=[];for(const r of i){const[...o]=rt(t,r,n),[a]=o;if(a[0])for(const[c]of o)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+ee(t),...s]}})}function Pe(){return pe("unknown",()=>!0)}function Le(i,e,t){return new se({...i,coercer:(n,s)=>xt(n,e)?i.coercer(t(n,s),s):i.coercer(n,s)})}const yt=()=>{const i=Ce.utils.randomPrivateKey(),e=Ze(i),t=new Uint8Array(64);return t.set(i),t.set(e,32),{publicKey:e,secretKey:t}},Ze=Ce.getPublicKey;function bt(i){try{return Ce.ExtendedPoint.fromHex(i),!0}catch{return!1}}const Ln=(i,e)=>Ce.sign(i,e.slice(0,32)),Nn=Ce.verify,q=i=>C.Buffer.isBuffer(i)?i:i instanceof Uint8Array?C.Buffer.from(i.buffer,i.byteOffset,i.byteLength):C.Buffer.from(i);class Kn{constructor(e){Object.assign(this,e)}encode(){return C.Buffer.from(an(Oe,this))}static decode(e){return cn(Oe,this,e)}static decodeUnchecked(e){return un(Oe,this,e)}}const Oe=new Map;var vt;let Pt;const Wn=32,de=32;function On(i){return i._bn!==void 0}let wt=1;Pt=Symbol.toStringTag;class _ extends Kn{constructor(e){if(super({}),this._bn=void 0,On(e))this._bn=e._bn;else{if(typeof e=="string"){const t=M.decode(e);if(t.length!=de)throw new Error("Invalid public key input");this._bn=new ft(t)}else this._bn=new ft(e);if(this._bn.byteLength()>de)throw new Error("Invalid public key input")}}static unique(){const e=new _(wt);return wt+=1,new _(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return M.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(C.Buffer);if(e.length===de)return e;const t=C.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Pt](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=C.Buffer.concat([e.toBuffer(),C.Buffer.from(t),n.toBuffer()]),r=gt(s);return new _(r)}static createProgramAddressSync(e,t){let n=C.Buffer.alloc(0);e.forEach(function(r){if(r.length>Wn)throw new TypeError("Max seed length exceeded");n=C.Buffer.concat([n,q(r)])}),n=C.Buffer.concat([n,t.toBuffer(),C.Buffer.from("ProgramDerivedAddress")]);const s=gt(n);if(bt(s))throw new Error("Invalid seeds, address must fall off the curve");return new _(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const r=e.concat(C.Buffer.from([n]));s=this.createProgramAddressSync(r,t)}catch(r){if(r instanceof TypeError)throw r;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new _(e);return bt(t.toBytes())}}vt=_;_.default=new vt("11111111111111111111111111111111");Oe.set(_,{kind:"struct",fields:[["_bn","u256"]]});new _("BPFLoader1111111111111111111111111111111111");const Se=1232,Lt=127,Nt=64;class at extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(at.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Kt extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Kt.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Re extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Re.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Fe{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((r,o)=>{n.set(r.toBase58(),o)});const s=r=>{const o=n.get(r.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return e.map(r=>({programIdIndex:s(r.programId),accountKeyIndexes:r.keys.map(o=>s(o.pubkey)),data:r.data}))}}const v=(i="publicKey")=>O(32,i),we=(i="string")=>{const e=I([B("length"),B("lengthPadding"),O(ke(B(),-8),"chars")],i),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(r,o)=>t(r,o).chars.toString(),s.encode=(r,o,a)=>{const c={chars:C.Buffer.from(r,"utf8")};return n(c,o,a)},s.alloc=r=>B().span+B().span+C.Buffer.from(r,"utf8").length,s},Fn=(i="authorized")=>I([v("staker"),v("withdrawer")],i),zn=(i="lockup")=>I([J("unixTimestamp"),J("epoch"),v("custodian")],i),Un=(i="voteInit")=>I([v("nodePubkey"),v("authorizedVoter"),v("authorizedWithdrawer"),P("commission")],i),qn=(i="voteAuthorizeWithSeedArgs")=>I([B("voteAuthorizationType"),v("currentAuthorityDerivedKeyOwnerPubkey"),we("currentAuthorityDerivedKeySeed"),v("newAuthorized")],i);function Wt(i,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const r=e[s.property];if(Array.isArray(r))return r.length*t(s.elementLayout)}else if("fields"in s)return Wt({layout:s},e[s.property]);return 0};let n=0;return i.layout.fields.forEach(s=>{n+=t(s)}),n}function X(i){let e=0,t=0;for(;;){let n=i.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Y(i,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){i.push(n);break}else n|=128,i.push(n)}}function W(i,e){if(!i)throw new Error(e||"Assertion failed")}class qe{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=o=>{const a=o.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},r=s(t);r.isSigner=!0,r.isWritable=!0;for(const o of e){s(o.programId).isInvoked=!0;for(const a of o.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new qe(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];W(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),r=e.filter(([,c])=>!c.isSigner&&!c.isWritable),o={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:r.length};{W(t.length>0,"Expected at least one writable signer key");const[c]=t[0];W(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new _(c)),...n.map(([c])=>new _(c)),...s.map(([c])=>new _(c)),...r.map(([c])=>new _(c))];return[o,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,r]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:r}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[r,o]of this.keyMetaMap.entries())if(t(o)){const a=new _(r),c=e.findIndex(l=>l.equals(a));c>=0&&(W(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(r))}return[n,s]}}const Ot="Reached end of buffer unexpectedly";function oe(i){if(i.length===0)throw new Error(Ot);return i.shift()}function Z(i,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw new Error(Ot);return i.splice(...e)}class ae{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new _(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:M.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Fe(this.staticAccountKeys)}static compile(e){const t=qe.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),o=new Fe(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:M.encode(a.data)}));return new ae({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,r=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<r}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Y(t,e);const n=this.instructions.map(k=>{const{accounts:R,programIdIndex:b}=k,m=Array.from(M.decode(k.data));let f=[];Y(f,R.length);let S=[];return Y(S,m.length),{programIdIndex:b,keyIndicesCount:C.Buffer.from(f),keyIndices:R,dataLength:C.Buffer.from(S),data:m}});let s=[];Y(s,n.length);let r=C.Buffer.alloc(Se);C.Buffer.from(s).copy(r);let o=s.length;n.forEach(k=>{const b=I([P("programIdIndex"),O(k.keyIndicesCount.length,"keyIndicesCount"),$(P("keyIndex"),k.keyIndices.length,"keyIndices"),O(k.dataLength.length,"dataLength"),$(P("userdatum"),k.data.length,"data")]).encode(k,r,o);o+=b}),r=r.slice(0,o);const a=I([O(1,"numRequiredSignatures"),O(1,"numReadonlySignedAccounts"),O(1,"numReadonlyUnsignedAccounts"),O(t.length,"keyCount"),$(v("key"),e,"keys"),v("recentBlockhash")]),c={numRequiredSignatures:C.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:C.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:C.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:C.Buffer.from(t),keys:this.accountKeys.map(k=>q(k.toBytes())),recentBlockhash:M.decode(this.recentBlockhash)};let l=C.Buffer.alloc(2048);const h=a.encode(c,l);return r.copy(l,h),l.slice(0,h+r.length)}static from(e){let t=[...e];const n=oe(t);if(n!==(n&Lt))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=oe(t),r=oe(t),o=X(t);let a=[];for(let R=0;R<o;R++){const b=Z(t,0,de);a.push(new _(C.Buffer.from(b)))}const c=Z(t,0,de),l=X(t);let h=[];for(let R=0;R<l;R++){const b=oe(t),m=X(t),f=Z(t,0,m),S=X(t),T=Z(t,0,S),z=M.encode(C.Buffer.from(T));h.push({programIdIndex:b,accounts:f,data:z})}const k={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:r},recentBlockhash:M.encode(C.Buffer.from(c)),accountKeys:a,instructions:h};return new ae(k)}}class Te{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Fe(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,r=this.addressTableLookups.reduce((o,a)=>o+a.writableIndexes.length,0);return s<r}else if(e>=this.header.numRequiredSignatures){const s=e-t,o=n-t-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(r=>r.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const r of n.writableIndexes)if(r<s.state.addresses.length)t.writable.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`);for(const r of n.readonlyIndexes)if(r<s.state.addresses.length)t.readonly.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=qe.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},r=e.addressLookupTableAccounts||[];for(const h of r){const k=t.extractTableLookup(h);if(k!==void 0){const[R,{writable:b,readonly:m}]=k;n.push(R),s.writable.push(...b),s.readonly.push(...m)}}const[o,a]=t.getMessageComponents(),l=new Fe(a,s).compileInstructions(e.instructions);return new Te({header:o,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:n})}serialize(){const e=Array();Y(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Y(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),r=Array();Y(r,this.addressTableLookups.length);const o=I([P("prefix"),I([P("numRequiredSignatures"),P("numReadonlySignedAccounts"),P("numReadonlyUnsignedAccounts")],"header"),O(e.length,"staticAccountKeysLength"),$(v(),this.staticAccountKeys.length,"staticAccountKeys"),v("recentBlockhash"),O(n.length,"instructionsLength"),O(t.length,"serializedInstructions"),O(r.length,"addressTableLookupsLength"),O(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Se),l=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(h=>h.toBytes()),recentBlockhash:M.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(r),serializedAddressTableLookups:s},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(Se);for(const n of this.compiledInstructions){const s=Array();Y(s,n.accountKeyIndexes.length);const r=Array();Y(r,n.data.length);const o=I([P("programIdIndex"),O(s.length,"encodedAccountKeyIndexesLength"),$(P(),n.accountKeyIndexes.length,"accountKeyIndexes"),O(r.length,"encodedDataLength"),O(n.data.length,"data")]);e+=o.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(r),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Se);for(const n of this.addressTableLookups){const s=Array();Y(s,n.writableIndexes.length);const r=Array();Y(r,n.readonlyIndexes.length);const o=I([v("accountKey"),O(s.length,"encodedWritableIndexesLength"),$(P(),n.writableIndexes.length,"writableIndexes"),O(r.length,"encodedReadonlyIndexesLength"),$(P(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=o.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(r),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=oe(t),s=n&Lt;W(n!==s,"Expected versioned message but received legacy message");const r=s;W(r===0,`Expected versioned message with version 0 but found version ${r}`);const o={numRequiredSignatures:oe(t),numReadonlySignedAccounts:oe(t),numReadonlyUnsignedAccounts:oe(t)},a=[],c=X(t);for(let m=0;m<c;m++)a.push(new _(Z(t,0,de)));const l=M.encode(Z(t,0,de)),h=X(t),k=[];for(let m=0;m<h;m++){const f=oe(t),S=X(t),T=Z(t,0,S),z=X(t),he=new Uint8Array(Z(t,0,z));k.push({programIdIndex:f,accountKeyIndexes:T,data:he})}const R=X(t),b=[];for(let m=0;m<R;m++){const f=new _(Z(t,0,de)),S=X(t),T=Z(t,0,S),z=X(t),he=Z(t,0,z);b.push({accountKey:f,writableIndexes:T,readonlyIndexes:he})}return new Te({header:o,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:k,addressTableLookups:b})}}let ue=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const Mn=C.Buffer.alloc(Nt).fill(0);class G{constructor(e){this.keys=void 0,this.programId=void 0,this.data=C.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class ie{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new G(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let f=0;f<t.length;f++)if(t[f].programId===void 0)throw new Error(`Transaction instruction index ${f} has undefined program id`);const s=[],r=[];t.forEach(f=>{f.keys.forEach(T=>{r.push({...T})});const S=f.programId.toString();s.includes(S)||s.push(S)}),s.forEach(f=>{r.push({pubkey:new _(f),isSigner:!1,isWritable:!1})});const o=[];r.forEach(f=>{const S=f.pubkey.toString(),T=o.findIndex(z=>z.pubkey.toString()===S);T>-1?(o[T].isWritable=o[T].isWritable||f.isWritable,o[T].isSigner=o[T].isSigner||f.isSigner):o.push(f)}),o.sort(function(f,S){if(f.isSigner!==S.isSigner)return f.isSigner?-1:1;if(f.isWritable!==S.isWritable)return f.isWritable?-1:1;const T={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return f.pubkey.toBase58().localeCompare(S.pubkey.toBase58(),"en",T)});const a=o.findIndex(f=>f.pubkey.equals(n));if(a>-1){const[f]=o.splice(a,1);f.isSigner=!0,f.isWritable=!0,o.unshift(f)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const f of this.signatures){const S=o.findIndex(T=>T.pubkey.equals(f.publicKey));if(S>-1)o[S].isSigner||(o[S].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${f.publicKey.toString()}`)}let c=0,l=0,h=0;const k=[],R=[];o.forEach(({pubkey:f,isSigner:S,isWritable:T})=>{S?(k.push(f.toString()),c+=1,T||(l+=1)):(R.push(f.toString()),T||(h+=1))});const b=k.concat(R),m=t.map(f=>{const{data:S,programId:T}=f;return{programIdIndex:b.indexOf(T.toString()),accounts:f.keys.map(z=>b.indexOf(z.pubkey.toString())),data:M.encode(S)}});return m.forEach(f=>{W(f.programIdIndex>=0),f.accounts.forEach(S=>W(S>=0))}),new ae({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:h},accountKeys:b,recentBlockhash:e,instructions:m})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,r)=>t[r].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}this.signatures=n.map(r=>({signature:null,publicKey:r.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const r=Ln(n,s.secretKey);this._addSignature(s.publicKey,q(r))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){W(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=C.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:r}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(r):Nn(s,e,r.toBytes())||(n.invalid||(n.invalid=[])).push(r);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const r=this._getMessageSignednessErrors(s,t);if(r){let o="Signature verification failed.";throw r.invalid&&(o+=`
Invalid signature for public key${r.invalid.length===1?"":"(s)"} [\`${r.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),r.missing&&(o+=`
Missing signature for public key${r.missing.length===1?"":"(s)"} [\`${r.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Y(n,t.length);const s=n.length+t.length*64+e.length,r=C.Buffer.alloc(s);return W(t.length<256),C.Buffer.from(n).copy(r,0),t.forEach(({signature:o},a)=>{o!==null&&(W(o.length===64,"signature has invalid length"),C.Buffer.from(o).copy(r,n.length+a*64))}),e.copy(r,n.length+t.length*64),W(r.length<=Se,`Transaction too large: ${r.length} > ${Se}`),r}get keys(){return W(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return W(this.instructions.length===1),this.instructions[0].programId}get data(){return W(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=X(t);let s=[];for(let r=0;r<n;r++){const o=Z(t,0,Nt);s.push(M.encode(C.Buffer.from(o)))}return ie.populate(ae.from(t),s)}static populate(e,t=[]){const n=new ie;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,r)=>{const o={signature:s==M.encode(Mn)?null:M.decode(s),publicKey:e.accountKeys[r]};n.signatures.push(o)}),e.instructions.forEach(s=>{const r=s.accounts.map(o=>{const a=e.accountKeys[o];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});n.instructions.push(new G({keys:r,programId:e.accountKeys[s.programIdIndex],data:M.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class ct{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:s,recentBlockhash:r}=e,{numRequiredSignatures:o,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,l=o-a;W(l>0,"Message header is invalid");const h=e.staticAccountKeys.length-o-c;W(h>=0,"Message header is invalid");const k=e.getAccountKeys(t),R=k.get(0);if(R===void 0)throw new Error("Failed to decompile message because no account keys were found");const b=[];for(const m of s){const f=[];for(const T of m.accountKeyIndexes){const z=k.get(T);if(z===void 0)throw new Error(`Failed to find key for account key index ${T}`);const he=T<o;let ce;he?ce=T<l:T<k.staticAccountKeys.length?ce=T-o<h:ce=T-k.staticAccountKeys.length<k.accountKeysFromLookups.writable.length,f.push({pubkey:z,isSigner:T<n.numRequiredSignatures,isWritable:ce})}const S=k.get(m.programIdIndex);if(S===void 0)throw new Error(`Failed to find program id for program id index ${m.programIdIndex}`);b.push(new G({programId:S,data:q(m.data),keys:f}))}return new ct({payerKey:R,instructions:b,recentBlockhash:r})}compileToLegacyMessage(){return ae.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Te.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}const Dn=160,Hn=64,Gn=Dn/Hn,$n=1e3/Gn;new _("SysvarC1ock11111111111111111111111111111111");new _("SysvarEpochSchedu1e111111111111111111111111");new _("Sysvar1nstructions1111111111111111111111111");const Ve=new _("SysvarRecentB1ockHashes11111111111111111111"),kt=new _("SysvarRent111111111111111111111111111111111");new _("SysvarRewards111111111111111111111111111111");new _("SysvarS1otHashes111111111111111111111111111");new _("SysvarS1otHistory11111111111111111111111111");new _("SysvarStakeHistory1111111111111111111111111");async function Fr(i,e,t,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},r=await i.sendTransaction(e,t,s);let o;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)o=(await i.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:r,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;o=(await i.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:r},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await i.confirmTransaction(r,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${r} failed (${JSON.stringify(o)})`);return r}function be(i){return new Promise(e=>setTimeout(e,i))}function H(i,e){const t=i.layout.span>=0?i.layout.span:Wt(i,e),n=C.Buffer.alloc(t),s=Object.assign({instruction:i.index},e);return i.layout.encode(s,n),n}const Vn=D("lamportsPerSignature"),Ft=I([B("version"),B("state"),v("authorizedPubkey"),v("nonce"),I([Vn],"feeCalculator")]),St=Ft.span;class ut{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Ft.decode(q(e),0);return new ut({authorizedPubkey:new _(t.authorizedPubkey),nonce:new _(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const jn=i=>{const e=i.decode.bind(i),t=i.encode.bind(i);return{decode:e,encode:t}},Jn=i=>e=>{const t=O(i,e),{encode:n,decode:s}=jn(t),r=t;return r.decode=(o,a)=>{const c=s(o,a);return ln(C.Buffer.from(c))},r.encode=(o,a,c)=>{const l=dn(o,i);return n(l,a,c)},r},_e=Jn(8),j=Object.freeze({Create:{index:0,layout:I([B("instruction"),J("lamports"),J("space"),v("programId")])},Assign:{index:1,layout:I([B("instruction"),v("programId")])},Transfer:{index:2,layout:I([B("instruction"),_e("lamports")])},CreateWithSeed:{index:3,layout:I([B("instruction"),v("base"),we("seed"),J("lamports"),J("space"),v("programId")])},AdvanceNonceAccount:{index:4,layout:I([B("instruction")])},WithdrawNonceAccount:{index:5,layout:I([B("instruction"),J("lamports")])},InitializeNonceAccount:{index:6,layout:I([B("instruction"),v("authorized")])},AuthorizeNonceAccount:{index:7,layout:I([B("instruction"),v("authorized")])},Allocate:{index:8,layout:I([B("instruction"),J("space")])},AllocateWithSeed:{index:9,layout:I([B("instruction"),v("base"),we("seed"),J("space"),v("programId")])},AssignWithSeed:{index:10,layout:I([B("instruction"),v("base"),we("seed"),v("programId")])},TransferWithSeed:{index:11,layout:I([B("instruction"),_e("lamports"),we("seed"),v("programId")])},UpgradeNonceAccount:{index:12,layout:I([B("instruction")])}});class ze{constructor(){}static createAccount(e){const t=j.Create,n=H(t,{lamports:e.lamports,space:e.space,programId:q(e.programId.toBuffer())});return new G({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const s=j.TransferWithSeed;t=H(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:q(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=j.Transfer;t=H(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new G({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const s=j.AssignWithSeed;t=H(s,{base:q(e.basePubkey.toBuffer()),seed:e.seed,programId:q(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=j.Assign;t=H(s,{programId:q(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new G({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=j.CreateWithSeed,n=H(t,{base:q(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:q(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new G({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){const t=new ie;"basePubkey"in e&&"seed"in e?t.add(ze.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:St,programId:this.programId})):t.add(ze.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:St,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=j.InitializeNonceAccount,n=H(t,{authorized:q(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:kt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new G(s)}static nonceAdvance(e){const t=j.AdvanceNonceAccount,n=H(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new G(s)}static nonceWithdraw(e){const t=j.WithdrawNonceAccount,n=H(t,{lamports:e.lamports});return new G({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:kt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=j.AuthorizeNonceAccount,n=H(t,{authorized:q(e.newAuthorizedPubkey.toBuffer())});return new G({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const s=j.AllocateWithSeed;t=H(s,{base:q(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:q(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=j.Allocate;t=H(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new G({keys:n,programId:this.programId,data:t})}}ze.programId=new _("11111111111111111111111111111111");new _("BPFLoader2111111111111111111111111111111111");function Xn(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Yn=Object.prototype.toString,Zn=Object.keys||function(i){var e=[];for(var t in i)e.push(t);return e};function Be(i,e){var t,n,s,r,o,a,c;if(i===!0)return"true";if(i===!1)return"false";switch(typeof i){case"object":if(i===null)return null;if(i.toJSON&&typeof i.toJSON=="function")return Be(i.toJSON(),e);if(c=Yn.call(i),c==="[object Array]"){for(s="[",n=i.length-1,t=0;t<n;t++)s+=Be(i[t],!0)+",";return n>-1&&(s+=Be(i[t],!0)),s+"]"}else if(c==="[object Object]"){for(r=Zn(i).sort(),n=r.length,s="",t=0;t<n;)o=r[t],a=Be(i[o],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(o)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(i);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(i);default:return isFinite(i)?i:null}}var Qn=function(i){var e=Be(i,!1);if(e!==void 0)return""+e},_t=Xn(Qn);const Ie=32;function je(i){let e=0;for(;i>1;)i/=2,e++;return e}function es(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class ts{constructor(e,t,n,s,r){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=r}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=je(es(e+Ie+1))-je(Ie)-1,n=this.getSlotsInEpoch(t),s=e-(n-Ie);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,r=t%this.slotsPerEpoch;return[s,r]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Ie:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+je(Ie)):this.slotsPerEpoch}}class Qe extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class A extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var ns=globalThis.fetch;class ss extends hn{constructor(e,t,n){const s=r=>{const o=gn(r,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function rs(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const At=56;class It{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=rs(os,e),n=e.length-At;W(n>=0,"lookup table is invalid"),W(n%32===0,"lookup table is invalid");const s=n/32,{addresses:r}=I([$(v(),s,"addresses")]).decode(e.slice(At));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new _(t.authority[0]):void 0,addresses:r.map(o=>new _(o))}}}const os={index:1,layout:I([B("typeIndex"),_e("deactivationSlot"),D("lastExtendedSlot"),P("lastExtendedStartIndex"),P(),$(v(),ke(P(),-1),"authority")])},is=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function as(i){const e=i.match(is);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,n,s,r]=e,o=i.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${o}//${n}${c}${r}`}const F=Le(ot(_),g(),i=>new _(i)),zt=it([g(),N("base64")]),lt=Le(ot(C.Buffer),zt,i=>C.Buffer.from(i[0],"base64")),cs=30*1e3;function us(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function L(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:n,...s}=i;e=n,t=s}return{commitment:e,config:t}}function Ut(i){return V([d({jsonrpc:N("2.0"),id:g(),result:i}),d({jsonrpc:N("2.0"),id:g(),error:d({code:Pe(),message:g(),data:E(vn())})})])}const ls=Ut(Pe());function x(i){return Le(Ut(i),ls,e=>"error"in e?e:{...e,result:p(e.result,i)})}function K(i){return x(d({context:d({slot:u()}),value:i}))}function Me(i){return d({context:d({slot:u()}),value:i})}function Je(i,e){return i===0?new Te({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new _(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:M.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ae(e)}const ds=d({foundation:u(),foundationTerm:u(),initial:u(),taper:u(),terminal:u()}),hs=x(w(y(d({epoch:u(),effectiveSlot:u(),amount:u(),postBalance:u(),commission:E(y(u()))})))),fs=w(d({slot:u(),prioritizationFee:u()})),gs=d({total:u(),validator:u(),foundation:u(),epoch:u()}),ps=d({epoch:u(),slotIndex:u(),slotsInEpoch:u(),absoluteSlot:u(),blockHeight:E(u()),transactionCount:E(u())}),ms=d({slotsPerEpoch:u(),leaderScheduleSlotOffset:u(),warmup:ne(),firstNormalEpoch:u(),firstNormalSlot:u()}),ys=Ct(g(),w(u())),me=y(V([d({}),g()])),bs=d({err:me}),ws=N("receivedSignature"),ks=d({"solana-core":g(),"feature-set":E(u())}),Rt=K(d({err:y(V([d({}),g()])),logs:y(w(g())),accounts:E(y(w(y(d({executable:ne(),owner:g(),lamports:u(),data:w(g()),rentEpoch:E(u())}))))),unitsConsumed:E(u()),returnData:E(y(d({programId:g(),data:it([g(),N("base64")])})))})),Ss=K(d({byIdentity:Ct(g(),w(u())),range:d({firstSlot:u(),lastSlot:u()})}));function _s(i,e,t,n,s,r){const o=t||ns;let a;r!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(h,k)=>{const R=await new Promise((b,m)=>{try{n(h,k,(f,S)=>b([f,S]))}catch(f){m(f)}});return await o(...R)}),new fn(async(h,k)=>{const R={method:"POST",body:h,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Ar)};try{let b=5,m,f=500;for(;c?m=await c(i,R):m=await o(i,R),!(m.status!==429||s===!0||(b-=1,b===0));)console.error(`Server responded with ${m.status} ${m.statusText}.  Retrying after ${f}ms delay...`),await be(f),f*=2;const S=await m.text();m.ok?k(null,S):k(new Error(`${m.status} ${m.statusText}: ${S}`))}catch(b){b instanceof Error&&k(b)}},{})}function As(i){return(e,t)=>new Promise((n,s)=>{i.request(e,t,(r,o)=>{if(r){s(r);return}n(o)})})}function Is(i){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(r=>i.request(r.methodName,r.args));i.request(s,(r,o)=>{if(r){n(r);return}t(o)})})}const Rs=x(ds),Bs=x(gs),Es=x(fs),Ts=x(ps),xs=x(ms),Cs=x(ys),vs=x(u()),Ps=K(d({total:u(),circulating:u(),nonCirculating:u(),nonCirculatingAccounts:w(F)})),et=d({amount:g(),uiAmount:y(u()),decimals:u(),uiAmountString:E(g())}),Ls=K(w(d({address:F,amount:g(),uiAmount:y(u()),decimals:u(),uiAmountString:E(g())}))),Ns=K(w(d({pubkey:F,account:d({executable:ne(),owner:F,lamports:u(),data:lt,rentEpoch:u()})}))),tt=d({program:g(),parsed:Pe(),space:u()}),Ks=K(w(d({pubkey:F,account:d({executable:ne(),owner:F,lamports:u(),data:tt,rentEpoch:u()})}))),Ws=K(w(d({lamports:u(),address:F}))),xe=d({executable:ne(),owner:F,lamports:u(),data:lt,rentEpoch:u()}),Os=d({pubkey:F,account:xe}),Fs=Le(V([ot(C.Buffer),tt]),V([zt,tt]),i=>Array.isArray(i)?p(i,lt):i),nt=d({executable:ne(),owner:F,lamports:u(),data:Fs,rentEpoch:u()}),zs=d({pubkey:F,account:nt}),Us=d({state:V([N("active"),N("inactive"),N("activating"),N("deactivating")]),active:u(),inactive:u()}),qs=x(w(d({signature:g(),slot:u(),err:me,memo:y(g()),blockTime:E(y(u()))}))),Ms=x(w(d({signature:g(),slot:u(),err:me,memo:y(g()),blockTime:E(y(u()))}))),Ds=d({subscription:u(),result:Me(xe)}),Hs=d({pubkey:F,account:xe}),Gs=d({subscription:u(),result:Me(Hs)}),$s=d({parent:u(),slot:u(),root:u()}),Vs=d({subscription:u(),result:$s}),js=V([d({type:V([N("firstShredReceived"),N("completed"),N("optimisticConfirmation"),N("root")]),slot:u(),timestamp:u()}),d({type:N("createdBank"),parent:u(),slot:u(),timestamp:u()}),d({type:N("frozen"),slot:u(),timestamp:u(),stats:d({numTransactionEntries:u(),numSuccessfulTransactions:u(),numFailedTransactions:u(),maxTransactionsPerEntry:u()})}),d({type:N("dead"),slot:u(),timestamp:u(),err:g()})]),Js=d({subscription:u(),result:js}),Xs=d({subscription:u(),result:Me(V([bs,ws]))}),Ys=d({subscription:u(),result:u()}),Zs=d({pubkey:g(),gossip:y(g()),tpu:y(g()),rpc:y(g()),version:y(g())}),Bt=d({votePubkey:g(),nodePubkey:g(),activatedStake:u(),epochVoteAccount:ne(),epochCredits:w(it([u(),u(),u()])),commission:u(),lastVote:u(),rootSlot:y(u())}),Qs=x(d({current:w(Bt),delinquent:w(Bt)})),er=V([N("processed"),N("confirmed"),N("finalized")]),tr=d({slot:u(),confirmations:y(u()),err:me,confirmationStatus:E(er)}),nr=K(w(y(tr))),sr=x(u()),qt=d({accountKey:F,writableIndexes:w(u()),readonlyIndexes:w(u())}),dt=d({signatures:w(g()),message:d({accountKeys:w(g()),header:d({numRequiredSignatures:u(),numReadonlySignedAccounts:u(),numReadonlyUnsignedAccounts:u()}),instructions:w(d({accounts:w(u()),data:g(),programIdIndex:u()})),recentBlockhash:g(),addressTableLookups:E(w(qt))})}),Mt=d({pubkey:F,signer:ne(),writable:ne(),source:E(V([N("transaction"),N("lookupTable")]))}),Dt=d({accountKeys:w(Mt),signatures:w(g())}),Ht=d({parsed:Pe(),program:g(),programId:F}),Gt=d({accounts:w(F),data:g(),programId:F}),rr=V([Gt,Ht]),or=V([d({parsed:Pe(),program:g(),programId:g()}),d({accounts:w(g()),data:g(),programId:g()})]),$t=Le(rr,or,i=>"accounts"in i?p(i,Gt):p(i,Ht)),Vt=d({signatures:w(g()),message:d({accountKeys:w(Mt),instructions:w($t),recentBlockhash:g(),addressTableLookups:E(y(w(qt)))})}),Ue=d({accountIndex:u(),mint:g(),owner:E(g()),uiTokenAmount:et}),jt=d({writable:w(F),readonly:w(F)}),De=d({err:me,fee:u(),innerInstructions:E(y(w(d({index:u(),instructions:w(d({accounts:w(u()),data:g(),programIdIndex:u()}))})))),preBalances:w(u()),postBalances:w(u()),logMessages:E(y(w(g()))),preTokenBalances:E(y(w(Ue))),postTokenBalances:E(y(w(Ue))),loadedAddresses:E(jt),computeUnitsConsumed:E(u())}),ht=d({err:me,fee:u(),innerInstructions:E(y(w(d({index:u(),instructions:w($t)})))),preBalances:w(u()),postBalances:w(u()),logMessages:E(y(w(g()))),preTokenBalances:E(y(w(Ue))),postTokenBalances:E(y(w(Ue))),loadedAddresses:E(jt),computeUnitsConsumed:E(u())}),Ae=V([N(0),N("legacy")]),ye=d({pubkey:g(),lamports:u(),postBalance:y(u()),rewardType:y(g()),commission:E(y(u()))}),ir=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:w(d({transaction:dt,meta:y(De),version:E(Ae)})),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),ar=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),cr=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:w(d({transaction:Dt,meta:y(De),version:E(Ae)})),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),ur=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:w(d({transaction:Vt,meta:y(ht),version:E(Ae)})),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),lr=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:w(d({transaction:Dt,meta:y(ht),version:E(Ae)})),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),dr=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),rewards:E(w(ye)),blockTime:y(u()),blockHeight:y(u())}))),hr=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:w(d({transaction:dt,meta:y(De)})),rewards:E(w(ye)),blockTime:y(u())}))),Et=x(y(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),signatures:w(g()),blockTime:y(u())}))),Xe=x(y(d({slot:u(),meta:y(De),blockTime:E(y(u())),transaction:dt,version:E(Ae)}))),Ne=x(y(d({slot:u(),transaction:Vt,meta:y(ht),blockTime:E(y(u())),version:E(Ae)}))),fr=K(d({blockhash:g(),feeCalculator:d({lamportsPerSignature:u()})})),gr=K(d({blockhash:g(),lastValidBlockHeight:u()})),pr=K(ne()),mr=d({slot:u(),numTransactions:u(),numSlots:u(),samplePeriodSecs:u()}),yr=x(w(mr)),br=K(y(d({feeCalculator:d({lamportsPerSignature:u()})}))),wr=x(g()),kr=x(g()),Sr=d({err:me,logs:w(g()),signature:g()}),_r=d({result:Me(Sr),subscription:u()}),Ar={"solana-client":"js/0.0.0-development"};class Ir{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async h=>{const{commitment:k,config:R}=L(h),b=this._buildArgs([],k,void 0,R),m=_t(b);return l[m]=l[m]??(async()=>{try{const f=await this._rpcRequest("getBlockHeight",b),S=p(f,x(u()));if("error"in S)throw new A(S.error,"failed to get block height information");return S.result}finally{delete l[m]}})(),await l[m]}})();let n,s,r,o,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,r=t.fetch,o=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=us(e),this._rpcWsEndpoint=n||as(e),this._rpcClient=_s(e,s,r,o,a,c),this._rpcRequest=As(this._rpcClient),this._rpcBatchRequest=Is(this._rpcClient),this._rpcWebSocket=new ss(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgs([e.toBase58()],n,void 0,s),o=await this._rpcRequest("getBalance",r),a=p(o,K(u()));if("error"in a)throw new A(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=p(t,x(y(u())));if("error"in n)throw new A(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=p(e,x(u()));if("error"in t)throw new A(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=p(e,vs);if("error"in t)throw new A(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=p(n,Ps);if("error"in s)throw new A(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),r=p(s,K(et));if("error"in r)throw new A(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),r=p(s,K(et));if("error"in r)throw new A(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:r}=L(n);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const a=this._buildArgs(o,s,"base64",r),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=p(c,Ns);if("error"in l)throw new A(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const r=this._buildArgs(s,n,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",r),a=p(o,Ks);if("error"in a)throw new A(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),r=p(s,Ws);if("error"in r)throw new A(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),r=p(s,Ls);if("error"in r)throw new A(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgs([e.toBase58()],n,"base64",s),o=await this._rpcRequest("getAccountInfo",r),a=p(o,K(y(xe)));if("error"in a)throw new A(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",r),a=p(o,K(y(nt)));if("error"in a)throw new A(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=L(t),r=e.map(l=>l.toBase58()),o=this._buildArgs([r],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",o),c=p(a,K(w(y(nt))));if("error"in c)throw new A(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=L(t),r=e.map(l=>l.toBase58()),o=this._buildArgs([r],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",o),c=p(a,K(w(y(xe))));if("error"in c)throw new A(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:r}=L(t),o=this._buildArgs([e.toBase58()],s,void 0,{...r,epoch:n??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getStakeActivation",o),c=p(a,x(Us));if("error"in c)throw new A(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=L(t),{encoding:r,...o}=s||{},a=this._buildArgs([e.toBase58()],n,r||"base64",o),c=await this._rpcRequest("getProgramAccounts",a),l=w(Os),h=o.withContext===!0?p(c,K(l)):p(c,x(l));if("error"in h)throw new A(h.error,`failed to get accounts owned by program ${e.toBase58()}`);return h.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",r),a=p(o,x(w(zs)));if("error"in a)throw new A(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var r;let n;if(typeof e=="string")n=e;else{const o=e;if((r=o.abortSignal)!=null&&r.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=M.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return W(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,r=!1;const o=new Promise((c,l)=>{try{n=this.onSignature(t,(k,R)=>{n=void 0;const b={context:R,value:k};c({__type:ue.PROCESSED,response:b})},e);const h=new Promise(k=>{n==null?k():s=this._onSubscriptionStateChange(n,R=>{R==="subscribed"&&k()})});(async()=>{if(await h,r)return;const k=await this.getSignatureStatus(t);if(r||k==null)return;const{context:R,value:b}=k;if(b!=null)if(b!=null&&b.err)l(b.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(b.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(b.confirmationStatus==="processed"||b.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}r=!0,c({__type:ue.PROCESSED,response:{context:R,value:b}})}})()}catch(h){l(h)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let r=!1;const o=new Promise(k=>{const R=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let b=await R();if(!r){for(;b<=n;)if(await be(1e3),r||(b=await R(),r))return;k({__type:ue.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let h;try{const k=await Promise.race([l,c,o]);if(k.__type===ue.PROCESSED)h=k.response;else throw new at(s)}finally{r=!0,a()}return h}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:r,signature:o}}){let a=!1;const c=new Promise(b=>{let m=r,f=null;const S=async()=>{try{const{context:T,value:z}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return f=T.slot,z==null?void 0:z.nonce}catch{return m}};(async()=>{if(m=await S(),!a)for(;;){if(r!==m){b({__type:ue.NONCE_INVALID,slotInWhichNonceDidAdvance:f});return}if(await be(2e3),a||(m=await S(),a))return}})()}),{abortConfirmation:l,confirmationPromise:h}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),k=this.getCancellationPromise(t);let R;try{const b=await Promise.race([k,h,c]);if(b.__type===ue.PROCESSED)R=b.response;else{let m;for(;;){const f=await this.getSignatureStatus(o);if(f==null)break;if(f.context.slot<(b.slotInWhichNonceDidAdvance??n)){await be(400);continue}m=f;break}if(m!=null&&m.value){const f=e||"finalized",{confirmationStatus:S}=m.value;switch(f){case"processed":case"recent":if(S!=="processed"&&S!=="confirmed"&&S!=="finalized")throw new Re(o);break;case"confirmed":case"single":case"singleGossip":if(S!=="confirmed"&&S!=="finalized")throw new Re(o);break;case"finalized":case"max":case"root":if(S!=="finalized")throw new Re(o);break;default:}R={context:m.context,value:{err:m.value.err}}}else throw new Re(o)}}finally{a=!0,l()}return R}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:ue.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:r,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([o,s]);if(c.__type===ue.PROCESSED)a=c.response;else throw new Kt(t,c.timeoutMs/1e3)}finally{clearTimeout(n),r()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=p(e,x(w(Zs)));if("error"in t)throw new A(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=p(n,Qs);if("error"in s)throw new A(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlot",s),o=p(r,x(u()));if("error"in o)throw new A(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlotLeader",s),o=p(r,x(g()));if("error"in o)throw new A(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),r=p(s,x(w(F)));if("error"in r)throw new A(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);W(s.length===1);const r=s[0];return{context:n,value:r}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),r=p(s,nr);if("error"in r)throw new A(r.error,"failed to get signature status");return r.result}async getTransactionCount(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getTransactionCount",s),o=p(r,x(u()));if("error"in o)throw new A(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=p(n,Rs);if("error"in s)throw new A(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:r}=L(n),o=this._buildArgs([e.map(l=>l.toBase58())],s,void 0,{...r,epoch:t??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getInflationReward",o),c=p(a,hs);if("error"in c)throw new A(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=p(e,Bs);if("error"in t)throw new A(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getEpochInfo",s),o=p(r,Ts);if("error"in o)throw new A(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=p(e,xs);if("error"in t)throw new A(t.error,"failed to get epoch schedule");const n=t.result;return new ts(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=p(e,Cs);if("error"in t)throw new A(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),r=p(s,sr);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=p(n,fr);if("error"in s)throw new A(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=p(t,yr);if("error"in n)throw new A(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),r=p(s,br);if("error"in r)throw new A(r.error,"failed to get fee calculator");const{context:o,value:a}=r.result;return{context:o,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=q(e.serialize()).toString("base64"),s=this._buildArgs([n],t),r=await this._rpcRequest("getFeeForMessage",s),o=p(r,K(y(u())));if("error"in o)throw new A(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var o;const t=(o=e==null?void 0:e.lockedWritableAccounts)==null?void 0:o.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),r=p(s,Es);if("error"in r)throw new A(r.error,"failed to get recent prioritization fees");return r.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getLatestBlockhash",s),o=p(r,gr);if("error"in o)throw new A(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgs([e],n,void 0,s),o=await this._rpcRequest("isBlockhashValid",r),a=p(o,pr);if("error"in a)throw new A(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=p(e,x(ks));if("error"in t)throw new A(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=p(e,x(g()));if("error"in t)throw new A(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=p(o,cr);if("error"in a)throw a.error;return a.result}case"none":{const a=p(o,ar);if("error"in a)throw a.error;return a.result}default:{const a=p(o,ir);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:h,version:k})=>({meta:h,transaction:{...l,message:Je(k,l.message)},version:k}))}:null}}}catch(a){throw new A(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=p(o,lr);if("error"in a)throw a.error;return a.result}case"none":{const a=p(o,dr);if("error"in a)throw a.error;return a.result}default:{const a=p(o,ur);if("error"in a)throw a.error;return a.result}}}catch(a){throw new A(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),r=await this._rpcRequest("getBlockProduction",s),o=p(r,Ss);if("error"in o)throw new A(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getTransaction",r),a=p(o,Xe);if("error"in a)throw new A(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Je(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=L(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getTransaction",r),a=p(o,Ne);if("error"in a)throw new A(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=L(t),r=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(r)).map(c=>{const l=p(c,Ne);if("error"in l)throw new A(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:n,config:s}=L(t),r=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(r)).map(c=>{const l=p(c,Xe);if("error"in l)throw new A(l.error,"failed to get transactions");const h=l.result;return h&&{...h,transaction:{...h.transaction,message:Je(h.version,h.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),r=p(s,hr);if("error"in r)throw new A(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");const a={...o,transactions:o.transactions.map(({transaction:c,meta:l})=>{const h=new ae(c.message);return{meta:l,transaction:{...c,message:h}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:ie.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),r=await this._rpcRequest("getBlocks",s),o=p(r,x(w(u())));if("error"in o)throw new A(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=p(s,Et);if("error"in r)throw new A(r.error,"failed to get block");const o=r.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),r=p(s,Et);if("error"in r)throw new A(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),r=p(s,Xe);if("error"in r)throw new A(r.error,"failed to get transaction");const o=r.result;if(!o)return o;const a=new ae(o.transaction.message),c=o.transaction.signatures;return{...o,transaction:ie.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),r=p(s,Ne);if("error"in r)throw new A(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(e,t){const n=e.map(o=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([o],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(o=>{const a=p(o,Ne);if("error"in a)throw new A(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},r=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<r));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let o=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>o));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=p(r,qs);if("error"in o)throw new A(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getSignaturesForAddress",s),o=p(r,Ms);if("error"in o)throw new A(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=new It({key:e,state:It.deserialize(s.data)})),{context:n,value:r}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=ut.fromAccountData(s.data)),{context:n,value:r}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=p(n,wr);if("error"in s)throw new A(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await be(100);const n=Date.now()-this._blockhashInfo.lastFetch>=cs;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const r=await this.getLatestBlockhash("finalized");if(n!==r.blockhash)return this._blockhashInfo={latestBlockhash:r,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},r;await be($n/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=L(e),s=this._buildArgs([],t,"base64",n),r=await this._rpcRequest("getStakeMinimumDelegation",s),o=p(r,K(u()));if("error"in o)throw new A(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,n){if("message"in e){const f=e.serialize(),S=C.Buffer.from(f).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const T=t||{};T.encoding="base64","commitment"in T||(T.commitment=this.commitment);const z=[S,T],he=await this._rpcRequest("simulateTransaction",z),ce=p(he,Rt);if("error"in ce)throw new Error("failed to simulate transaction: "+ce.error.message);return ce.result}let s;if(e instanceof ie){let m=e;s=new ie,s.feePayer=m.feePayer,s.instructions=e.instructions,s.nonceInfo=m.nonceInfo,s.signatures=m.signatures}else s=ie.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(s.nonceInfo&&r)s.sign(...r);else{let m=this._disableBlockhashCaching;for(;;){const f=await this._blockhashWithExpiryBlockHeight(m);if(s.lastValidBlockHeight=f.lastValidBlockHeight,s.recentBlockhash=f.blockhash,!r)break;if(s.sign(...r),!s.signature)throw new Error("!signature");const S=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(S)&&!this._blockhashInfo.transactionSignatures.includes(S)){this._blockhashInfo.simulatedSignatures.push(S);break}else m=!0}}const o=s._compile(),a=o.serialize(),l=s._serialize(a).toString("base64"),h={encoding:"base64",commitment:this.commitment};if(n){const m=(Array.isArray(n)?n:o.nonProgramIds()).map(f=>f.toBase58());h.accounts={encoding:"base64",addresses:m}}r&&(h.sigVerify=!0);const k=[l,h],R=await this._rpcRequest("simulateTransaction",k),b=p(R,Rt);if("error"in b){let m;if("data"in b.error&&(m=b.error.data.logs,m&&Array.isArray(m))){const f=`
    `,S=f+m.join(f);console.error(b.error.message,S)}throw new Qe("failed to simulate transaction: "+b.error.message,m)}return b.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))o=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const r=e.serialize();return await this.sendRawTransaction(r,n)}async sendRawTransaction(e,t){const n=q(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,r=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),r&&(n.preflightCommitment=r);const o=[e,n],a=await this._rpcRequest("sendTransaction",o),c=p(a,kr);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new Qe("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:r,method:o}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(o,r);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${o} error for argument`,r,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[r])}catch(a){if(a instanceof Error&&console.error(`${o} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(r){console.error(r)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=p(e,Ds);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=_t([e.method,t]),r=this._subscriptionsByHash[s];return r===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:r.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const o=this._subscriptionsByHash[s];W(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=p(e,Gs);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const r=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},r)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=p(e,_r);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=p(e,Vs);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=p(e,Js);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const r=t||this._commitment;if(r||n||s){let o={};n&&(o.encoding=n),r&&(o.commitment=r),s&&(o=Object.assign(o,s)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const r=t||this._commitment;if(r&&!["confirmed","finalized"].includes(r))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=p(e,Xs);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),r=this._makeSubscription({callback:(o,a)=>{if(o.type==="status"){t(o.result,a);try{this.removeSignatureListener(r)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return r}onSignatureWithOptions(e,t,n){const{commitment:s,...r}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},o=this._buildArgs([e],s,void 0,r),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=p(e,Ys);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Ee{constructor(e){this._keypair=void 0,this._keypair=e??yt()}static generate(){return new Ee(yt())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),r=Ze(s);for(let o=0;o<32;o++)if(n[o]!==r[o])throw new Error("provided secretKey is invalid")}return new Ee({publicKey:n,secretKey:e})}static fromSeed(e){const t=Ze(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Ee({publicKey:t,secretKey:n})}get publicKey(){return new _(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:I([B("instruction"),_e("recentSlot"),P("bumpSeed")])},FreezeLookupTable:{index:1,layout:I([B("instruction")])},ExtendLookupTable:{index:2,layout:I([B("instruction"),_e(),$(v(),ke(B(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:I([B("instruction")])},CloseLookupTable:{index:4,layout:I([B("instruction")])}});new _("AddressLookupTab1e1111111111111111111111111");const Ke=Object.freeze({RequestUnits:{index:0,layout:I([P("instruction"),B("units"),B("additionalFee")])},RequestHeapFrame:{index:1,layout:I([P("instruction"),B("bytes")])},SetComputeUnitLimit:{index:2,layout:I([P("instruction"),B("units")])},SetComputeUnitPrice:{index:3,layout:I([P("instruction"),_e("microLamports")])}});class st{constructor(){}static requestUnits(e){const t=Ke.RequestUnits,n=H(t,e);return new G({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=Ke.RequestHeapFrame,n=H(t,e);return new G({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=Ke.SetComputeUnitLimit,n=H(t,e);return new G({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=Ke.SetComputeUnitPrice,n=H(t,{microLamports:BigInt(e.microLamports)});return new G({keys:[],programId:this.programId,data:n})}}st.programId=new _("ComputeBudget111111111111111111111111111111");I([P("numSignatures"),P("padding"),Q("signatureOffset"),Q("signatureInstructionIndex"),Q("publicKeyOffset"),Q("publicKeyInstructionIndex"),Q("messageDataOffset"),Q("messageDataSize"),Q("messageInstructionIndex")]);new _("Ed25519SigVerify111111111111111111111111111");Tt.utils.isValidPrivateKey;Tt.getPublicKey;I([P("numSignatures"),Q("signatureOffset"),P("signatureInstructionIndex"),Q("ethAddressOffset"),P("ethAddressInstructionIndex"),Q("messageDataOffset"),Q("messageDataSize"),P("messageInstructionIndex"),O(20,"ethAddress"),O(64,"signature"),P("recoveryId")]);new _("KeccakSecp256k11111111111111111111111111111");var Jt;new _("StakeConfig11111111111111111111111111111111");class Xt{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Jt=Xt;Xt.default=new Jt(0,0,_.default);Object.freeze({Initialize:{index:0,layout:I([B("instruction"),Fn(),zn()])},Authorize:{index:1,layout:I([B("instruction"),v("newAuthorized"),B("stakeAuthorizationType")])},Delegate:{index:2,layout:I([B("instruction")])},Split:{index:3,layout:I([B("instruction"),J("lamports")])},Withdraw:{index:4,layout:I([B("instruction"),J("lamports")])},Deactivate:{index:5,layout:I([B("instruction")])},Merge:{index:7,layout:I([B("instruction")])},AuthorizeWithSeed:{index:8,layout:I([B("instruction"),v("newAuthorized"),B("stakeAuthorizationType"),we("authoritySeed"),v("authorityOwner")])}});new _("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:I([B("instruction"),Un()])},Authorize:{index:1,layout:I([B("instruction"),v("newAuthorized"),B("voteAuthorizationType")])},Withdraw:{index:3,layout:I([B("instruction"),J("lamports")])},UpdateValidatorIdentity:{index:4,layout:I([B("instruction")])},AuthorizeWithSeed:{index:10,layout:I([B("instruction"),qn()])}});new _("Vote111111111111111111111111111111111111111");new _("Va1idator1nfo111111111111111111111111111111");d({name:g(),website:E(g()),details:E(g()),keybaseUsername:E(g())});new _("Vote111111111111111111111111111111111111111");I([v("nodePubkey"),v("authorizedWithdrawer"),P("commission"),D(),$(I([D("slot"),B("confirmationCount")]),ke(B(),-8),"votes"),P("rootSlotValid"),D("rootSlot"),D(),$(I([D("epoch"),v("authorizedVoter")]),ke(B(),-8),"authorizedVoters"),I([$(I([v("authorizedPubkey"),D("epochOfLastAuthorizedSwitch"),D("targetEpoch")]),32,"buf"),D("idx"),P("isEmpty")],"priorVoters"),D(),$(I([D("epoch"),D("credits"),D("prevCredits")]),ke(B(),-8),"epochCredits"),I([D("slot"),D("timestamp")],"lastTimestamp")]);const He="Solana",Rr="11111111111111111111111111111111",fe=class fe{constructor(e){U(this,"type","Native");U(this,"address");fe.instanceof(e)?this.address=e.address:pt.instanceof(e)?this.address=new _(e.toUint8Array()):typeof e=="string"&&Ye.valid(e)?this.address=new _(Ye.decode(e)):this.address=new _(e)}unwrap(){return this.address}toString(){return this.address.toBase58()}toUint8Array(){return new Uint8Array(this.address.toBytes())}toNative(){return this}toUniversalAddress(){return new pt(this.toUint8Array())}static instanceof(e){return e.constructor.platform===fe.platform}equals(e){return fe.instanceof(e)?e.unwrap().equals(this.unwrap()):this.toUniversalAddress().equals(e)}};U(fe,"byteSize",32),U(fe,"platform",He);let te=fe;pn(He,te);class Yt extends An{async getTokenAccount(e,t){const{getAssociatedTokenAddress:n}=await We(()=>import("./index-WaFPCx4Z.js"),__vite__mapDeps([0,1,2,3])),s=new te(t).unwrap(),r=new te(e).unwrap(),o=await n(s,r);return{chain:this.chain,address:new te(o.toString())}}}const Zt=new _("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),zr=new _("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),Ur=new _("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),qr=new _("So11111111111111111111111111111111111111112"),Mr=new _("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");function Dr(i){return i!==Zt}const re=class re extends In{constructor(e,t){super(e,t??mn(e,re._platform))}getRpc(e,t={commitment:"confirmed",disableRetryOnRateLimit:!0}){if(e in this.config)return new Ir(this.config[e].rpc,t);throw new Error("No configuration available for chain: "+e)}getChain(e,t){if(e in this.config)return new Yt(e,this,t);throw new Error("No configuration available for chain: "+e)}static nativeTokenId(e,t){if(!re.isSupportedChain(t))throw new Error(`invalid chain: ${t}`);return yn.chainAddress(t,Rr)}static isNativeTokenId(e,t,n){return!this.isSupportedChain(t)||n.chain!==t?!1:this.nativeTokenId(e,t)==n}static isSupportedChain(e){return bn(e)===re._platform}static async getDecimals(e,t,n){if($e(n))return wn(re._platform);let s=await t.getParsedAccountInfo(new te(n).unwrap());if(!s||!s.value)throw new Error("could not fetch token details");const{decimals:r}=s.value.data.parsed.info;return r}static async getBalance(e,t,n,s){const r=new _(n);if($e(s))return BigInt(await t.getBalance(r));const o=await t.getTokenAccountsByOwner(r,{mint:new te(s).unwrap()}),a=o.value.length>0?o.value[0].pubkey:r,c=await t.getTokenAccountBalance(a);return BigInt(c.value.amount)}static async getBalances(e,t,n,s){let r;s.includes("native")&&(r=BigInt(await t.getBalance(new _(n))));const o=await t.getParsedTokenAccountsByOwner(new _(n),{programId:new _(Zt)});return s.map(c=>{var k,R,b,m;if($e(c))return{native:r};const l=new te(c).toString(),h=(m=(b=(R=(k=o.value.find(f=>{var S,T;return((T=(S=f==null?void 0:f.account.data.parsed)==null?void 0:S.info)==null?void 0:T.mint)===c}))==null?void 0:k.account.data.parsed)==null?void 0:R.info)==null?void 0:b.tokenAmount)==null?void 0:m.amount;return h?{[l]:BigInt(h)}:{[l]:null}}).reduce((c,l)=>Object.assign(c,l),{})}static async sendWait(e,t,n,s){const{blockhash:r,lastValidBlockHeight:o}=await this.latestBlock(t),a=await Promise.all(n.map(h=>t.sendRawTransaction(h,s??{preflightCommitment:t.commitment}))),l=(await Promise.all(a.map(h=>t.confirmTransaction({signature:h,blockhash:r,lastValidBlockHeight:o},t.commitment)))).filter(h=>h.value.err).map(h=>h.value.err);if(l.length>0)throw new Error(`Failed to confirm transaction: ${l}`);return a}static async latestBlock(e,t){return e.getLatestBlockhash(t??e.commitment)}static async getLatestBlock(e){return await e.getSlot()}static async getLatestFinalizedBlock(e){const{lastValidBlockHeight:t}=await this.latestBlock(e,"finalized");return t}static chainFromChainId(e){const t=kn(re._platform,e);if(!t)throw new Error(`No matching genesis hash to determine network and chain: ${e}`);const[n,s]=t;return[n,s]}static async chainFromRpc(e){try{const t=await e.getGenesisHash();return re.chainFromChainId(t)}catch(t){if(e.rpcEndpoint.includes("http://127")||e.rpcEndpoint.includes("http://localhost")||e.rpcEndpoint==="http://solana-devnet:8899")return["Devnet","Solana"];throw t}}};U(re,"_platform",He);let ge=re;class Hr{constructor(e,t,n,s,r=!1){U(this,"transaction");U(this,"network");U(this,"chain");U(this,"description");U(this,"parallelizable");this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=r}}function Ge(i){return i.signatures!==void 0&&i.message!==void 0}const Qt=.5,en=1,tn=1,nn=1e9,sn=5,Br=25e4;async function Er(i,e,t){const[n,s]=await ge.chainFromRpc(i),r=typeof e=="string"?Ee.fromSecretKey(Sn.decode(e)):e;if(t!=null&&t.priorityFee&&t.priorityFee.percentile&&t.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new Tr(i,s,r,(t==null?void 0:t.debug)??!1,(t==null?void 0:t.priorityFee)??{},(t==null?void 0:t.retries)??sn,t==null?void 0:t.sendOpts)}class Tr{constructor(e,t,n,s=!1,r,o=sn,a){U(this,"_rpc");U(this,"_chain");U(this,"_keypair");U(this,"_debug");U(this,"_priorityFee");U(this,"_maxResubmits");U(this,"_sendOpts");this._rpc=e,this._chain=t,this._keypair=n,this._debug=s,this._priorityFee=r,this._maxResubmits=o,this._sendOpts=a,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(e){var n;if(e instanceof at)return!0;if(!(e instanceof Qe)||!e.message.includes("Transaction simulation failed"))return!1;if(e.message.includes("Blockhash not found"))return!0;const t=(n=e.logs)==null?void 0:n.find(s=>s.startsWith("Program log: Error: "));return t?!!(t.includes("Not enough bytes")||t.includes("Unexpected length of input")):!1}async signAndSend(e){var a;let{blockhash:t,lastValidBlockHeight:n}=await ge.latestBlock(this._rpc);const s=[];for(const c of e){const{description:l,transaction:{transaction:h,signers:k}}=c;this._debug&&console.log(`Signing: ${l} for ${this.address()}`);let R;(a=this._priorityFee)!=null&&a.percentile&&this._priorityFee.percentile>0&&(R=await Cr(this._rpc,h,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&xr(h);for(let b=0;b<this._maxResubmits;b++)try{if(Ge(h)){if(R){const f=ct.decompile(h.message);f.instructions.push(...R),h.message=f.compileToV0Message()}h.message.recentBlockhash=t,h.sign([this._keypair,...k??[]])}else R&&h.add(...R),h.recentBlockhash=t,h.partialSign(this._keypair,...k??[]);this._debug&&console.log("Submitting transactions ");const m=await this._rpc.sendRawTransaction(h.serialize(),this._sendOpts);s.push(m);break}catch(m){if(b===this._maxResubmits-1||!this.retryable(m))throw m;this._debug&&console.log(`Failed to send transaction on attempt ${b}, retrying: `,m);const{blockhash:f,lastValidBlockHeight:S}=await ge.latestBlock(this._rpc);n=S,t=f}}this._debug&&console.log("Waiting for confirmation for: ",s);const o=(await Promise.all(s.map(async c=>{try{return await this._rpc.confirmTransaction({signature:c,blockhash:t,lastValidBlockHeight:n},this._rpc.commitment)}catch(l){throw console.error("Failed to confirm transaction: ",l),l}}))).filter(c=>c.value.err).map(c=>c.value.err);if(o.length>0)throw new Error(`Failed to confirm transaction: ${o}`);return s}}function xr(i){if(Ge(i)){console.log(i.signatures);const e=i.message,t=e.getAccountKeys();e.compiledInstructions.forEach(n=>{console.log("Program",t.get(n.programIdIndex).toBase58()),console.log("Data: ",Ye.encode(n.data)),console.log("Keys: ",n.accountKeyIndexes.map(s=>[s,t.get(s).toBase58()]))})}else console.log(i.signatures),console.log(i.feePayer),i.instructions.forEach(e=>{console.log("Program",e.programId.toBase58()),console.log("Data: ",e.data.toString("hex")),console.log("Keys: ",e.keys.map(t=>[t,t.pubkey.toBase58()]))})}async function Cr(i,e,t=Qt,n=en,s=tn,r=nn){const[o,a]=await Promise.all([vr(i,e),Pr(i,e,t,n,s,r)]);return[st.setComputeUnitLimit({units:o}),st.setComputeUnitPrice({microLamports:a})]}async function vr(i,e){var n;let t=Br;try{const s=await(Ge(e),i.simulateTransaction(e));s.value.err&&console.error(`Error simulating Solana transaction: ${s.value.err}`),(n=s==null?void 0:s.value)!=null&&n.unitsConsumed&&(t=Math.round(s.value.unitsConsumed*1.2))}catch(s){console.error(`Failed to calculate compute unit limit for Solana transaction: ${s}`)}return t}async function Pr(i,e,t=Qt,n=en,s=tn,r=nn){let o=s,a=[];if(Ge(e)){const c=e.message,l=c.getAccountKeys();a=c.compiledInstructions.flatMap(h=>h.accountKeyIndexes).map(h=>c.isAccountWritable(h)?l.get(h):null).filter(h=>h!==null)}else a=e.instructions.flatMap(c=>c.keys).map(c=>c.isWritable?c.pubkey:null).filter(c=>c!==null);try{const c=await i.getRecentPrioritizationFees({lockedWritableAccounts:a});if(c){const l=c.map(k=>k.prioritizationFee).sort((k,R)=>k-R),h=Math.ceil(l.length*t);if(l.length>h){let k=l[h];n>0&&(k*=n),o=Math.max(o,k)}}}catch(c){console.error("Error fetching Solana recent fees",c)}return Math.min(Math.max(o,s),r)}const Lr={Address:te,Platform:ge,getSigner:Er,protocols:{WormholeCore:()=>We(()=>import("./index-DTi89_IP.js").then(i=>i.o),__vite__mapDeps([4,1,2,5,6,3])),TokenBridge:()=>We(()=>import("./index-DsBgYJHX.js"),__vite__mapDeps([7,4,1,2,5,6,3])),CircleBridge:()=>We(()=>import("./index-BaiE0GrD.js"),__vite__mapDeps([8,1,2,3,5]))},getChain:(i,e,t)=>new Yt(e,new ge(i,_n(i,He,{[e]:t})))},Gr=Object.freeze(Object.defineProperty({__proto__:null,default:Lr},Symbol.toStringTag,{value:"Module"}));export{Ur as A,Ee as K,Mr as N,_ as P,ge as S,G as T,He as _,te as a,Hr as b,Zt as c,ie as d,zr as e,kt as f,ze as g,qr as h,Gr as i,Dr as p,Fr as s};
